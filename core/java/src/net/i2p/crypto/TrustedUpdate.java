package net.i2p.crypto;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.StringTokenizer;

import net.i2p.I2PAppContext;
import net.i2p.data.DataFormatException;
import net.i2p.data.DataHelper;
import net.i2p.data.Signature;
import net.i2p.data.SigningPrivateKey;
import net.i2p.data.SigningPublicKey;
import net.i2p.util.Log;

/**
 * Handles DSA signing and verification of I2P update archives.
 * 
 * @author smeghead
 */
public class TrustedUpdate {
    /**
     * default trusted key, generated by jrandom.  This can be authenticated
     * via gpg without modification (gpg --verify TrustedUpdate.java)
     *
     */
/*
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

*/
    private static final String DEFAULT_TRUSTED_KEY =
        "W4kJbnv9KSVwbnapV7SaNW2kMIZKs~hwL0ro9pZXFo1xTwqz45nykCp1H" +
        "M7sAKYDZay5z1HvYYOl9CNVz00xF03KPU9RUCVxhDZ1YXhZIskPKjUPUs" +
        "CIpE~Z1C~N9KSEV6~2stDlBNH10VZ4T0X1TrcXwb3IBXliWo2y2GAx~Ow=";
/*
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.2.4 (GNU/Linux)

iD8DBQFCQXoJGnFL2th344YRAtsIAKCUy/sOIsxahUnT2hKLXFL9lXsAmACfUHa5
CPah6TDXYJCWmR0n3oPtrvo=
=mD0t
-----END PGP SIGNATURE-----
*/

    private ArrayList _trustedKeys;

    private I2PAppContext _context;
    private Log           _log;

    private static final int VERSION_BYTES = 16;
    private static final int HEADER_BYTES = VERSION_BYTES + Signature.SIGNATURE_BYTES;
    
    public static final String PROP_TRUSTED_KEYS = "router.trustedUpdateKeys";
    
    public TrustedUpdate() {
        this(I2PAppContext.getGlobalContext());
    }
    public TrustedUpdate(I2PAppContext ctx) {
        _context = ctx;
        _log = _context.logManager().getLog(TrustedUpdate.class);
        _trustedKeys = new ArrayList(1);
        String keys = ctx.getProperty(PROP_TRUSTED_KEYS);
        if ( (keys != null) && (keys.length() > 0) ) {
            StringTokenizer tok = new StringTokenizer(keys, ", ");
            while (tok.hasMoreTokens())
                _trustedKeys.add(tok.nextToken());
        } else {
            _trustedKeys.add(DEFAULT_TRUSTED_KEY);
        }
    }
    
    public ArrayList getTrustedKeys() { return _trustedKeys; }
    
	public static void main(String[] args) {
        if (args.length <= 0) {
            usage();
        } else if ("keygen".equals(args[0])) {
            genKeysCLI(args[1], args[2]);
        } else if ("sign".equals(args[0])) {
            signCLI(args[1], args[2], args[3], args[4]);
        } else if ("verify".equals(args[0])) {
            verifyCLI(args[1]);
        } else {
            usage();
        }
	}

    private static final void usage() {
        System.err.println("Usage: TrustedUpdate keygen publicKeyFile privateKeyFile");
        System.err.println("       TrustedUpdate sign   origFile signedFile privateKeyFile version");
        System.err.println("       TrustedUpdate verify signedFile");
    }
    
    private static final void genKeysCLI(String publicKeyFile, String privateKeyFile) {
        FileOutputStream out = null;
        try {
            I2PAppContext ctx = I2PAppContext.getGlobalContext();
            Object keys[] = ctx.keyGenerator().generateSigningKeypair();
            SigningPublicKey pub = (SigningPublicKey)keys[0];
            SigningPrivateKey priv = (SigningPrivateKey)keys[1];
            
            out = new FileOutputStream(publicKeyFile);
            pub.writeBytes(out);
            out.close();
            
            out = new FileOutputStream(privateKeyFile);
            priv.writeBytes(out);
            out.close();
            out = null;
            System.out.println("Private keys writen to " + privateKeyFile + " and public to " + publicKeyFile);
            System.out.println("Public: " + pub.toBase64());
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println("Error writing out the keys");
        } finally {
            if (out != null) try { out.close(); } catch (IOException ioe) {}
        }
    }

    private static final void signCLI(String origFile, String outFile, String privKeyFile, String version) {
        TrustedUpdate up = new TrustedUpdate();
        Signature sig = up.sign(origFile, outFile, privKeyFile, version);
        if (sig != null)
            System.out.println("Signed and written to " + outFile);
        else
            System.out.println("Error signing");
    }
    
    private static final void verifyCLI(String signedFile) {
        TrustedUpdate up = new TrustedUpdate();
        boolean ok = up.verify(signedFile);
        if (ok)
            System.out.println("Signature VALID");
        else
            System.out.println("Signature INVALID");
    }

	/**
	 * Reads the version string from a signed I2P update file.
	 * 
	 * @param inputFile A signed I2P update file.
	 * 
	 * @return The update version string read, or an empty string if no version
	 *         string is present.
	 */
	public String getUpdateVersion(String inputFile) {
        FileInputStream in = null;
        try {
            in = new FileInputStream(inputFile);
            byte data[] = new byte[VERSION_BYTES];
            int read = DataHelper.read(in, data);
            if (read != VERSION_BYTES)
                return null;
            for (int i = 0; i < VERSION_BYTES; i++) 
                if (data[i] == 0x00)
                    return new String(data, 0, i, "UTF-8");
            return new String(data, "UTF-8");
        } catch (UnsupportedEncodingException uee) {
			// If this ever gets called, you need a new JVM.
            throw new RuntimeException("wtf, your JVM doesnt support utf-8? " + uee.getMessage());
		} catch (IOException ioe) {
            return "";
        } finally {
            if (in != null) try { in.close(); } catch (IOException ioe) {}
        }
	}

	/**
	 * Uses the given private key to sign the given input file with DSA. The
	 * output will be a binary file where the first 16 bytes are the I2P
	 * update's version string encoded in UTF-8 (padded with trailing
	 * <code>0h</code> characters if necessary), the next 40 bytes are the
	 * resulting DSA signature, and the remaining bytes are the input file.
	 * 
	 * @param inputFile      The file to be signed.
	 * @param outputFile     The signed file to write.
	 * @param privateKeyFile The name of the file containing the private key to
	 *                       sign <code>inputFile</code> with.
	 * @param updateVersion  The version number of the I2P update. If this
	 *                       string is longer than 16 characters it will be
	 *                       truncated.
	 * 
	 * @return An instance of {@link net.i2p.data.Signature}, or null if there was an error
	 */
	public Signature sign(String inputFile, String outputFile, String privateKeyFile, String updateVersion) {
        SigningPrivateKey key = new SigningPrivateKey();
        FileInputStream in = null;
        try {
            in = new FileInputStream(privateKeyFile);
            key.readBytes(in);
        } catch (IOException ioe) {
            if (_log.shouldLog(Log.WARN))
                _log.warn("Unable to load the signing key", ioe);
            return null;
        } catch (DataFormatException dfe) {
            if (_log.shouldLog(Log.WARN))
                _log.warn("Unable to load the signing key", dfe);
            return null;
        } finally {
            if (in != null) try { in.close(); } catch (IOException ioe) {}
        }
        
        return sign(inputFile, outputFile, key, updateVersion);
    }
    
	public Signature sign(String inputFile, String outputFile, SigningPrivateKey privKey, String updateVersion) {
		byte[] headerUpdateVersion = {
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00 };
		byte[] updateVersionBytes = null;
		if (updateVersion.length() > VERSION_BYTES)
			updateVersion = updateVersion.substring(0, VERSION_BYTES);
		try {
			updateVersionBytes = updateVersion.getBytes("UTF-8");
		} catch (UnsupportedEncodingException e) {
			// If this ever gets called, you need a new JVM.
            throw new RuntimeException("wtf, your JVM doesnt support utf-8? " + e.getMessage());
		}
        System.arraycopy(updateVersionBytes, 0, headerUpdateVersion, 0, updateVersionBytes.length);

        Signature signature = null;
        FileInputStream in = null;
        try {
            in = new FileInputStream(inputFile);
            signature = _context.dsa().sign(in, privKey);
        } catch (Exception e) {
            if (_log.shouldLog(Log.ERROR))
                _log.error("Error signing", e);
            return null;
        } finally {
            if (in != null) try { in.close(); } catch (IOException ioe) {}
            in = null;
        }
        FileOutputStream fileOutputStream = null;
        try {
			fileOutputStream = new FileOutputStream(outputFile);
			fileOutputStream.write(headerUpdateVersion);
			fileOutputStream.write(signature.getData());
            
            in = new FileInputStream(inputFile);
            byte buf[] = new byte[1024];
            int read = 0;
            while ( (read = in.read(buf)) != -1) 
                fileOutputStream.write(buf, 0, read);
			fileOutputStream.close();
            fileOutputStream = null;
		} catch (IOException ioe) {
			if (_log.shouldLog(Log.WARN))
				_log.log(Log.WARN, "Error writing signed I2P update file " + outputFile, ioe);
            return null;
		} finally {
            if (fileOutputStream != null) try { fileOutputStream.close(); } catch (IOException ioe) {}
            if (in != null) try { in.close(); } catch (IOException ioe) {}
        }

		return signature;
	}

	/**
	 * Verifies the DSA signature of a signed I2P update.
	 * 
	 * @param inputFile The signed update file to check.
	 * 
	 * @return <code>true</code> if the file has a valid signature.
	 */
	public boolean verify(String inputFile) {
        for (int i = 0; i < _trustedKeys.size(); i++) {
            SigningPublicKey key = new SigningPublicKey();
            try {
                key.fromBase64((String)_trustedKeys.get(i));
                boolean ok = verify(inputFile, key);
                if (ok) return true;
            } catch (DataFormatException dfe) {
                _log.log(Log.CRIT, "Trusted key " + i + " is not valid");
            }
        }
        if (_log.shouldLog(Log.WARN))
            _log.warn("None of the keys match");
        return false;
    }
    
	/**
	 * Verifies the DSA signature of a signed I2P update.
	 * 
	 * @param inputFile The signed update file to check.
     * @param key public key to verify against
	 * 
	 * @return <code>true</code> if the file has a valid signature.
	 */
    public boolean verify(String inputFile, SigningPublicKey key) {
        FileInputStream in = null;
        try {
            in = new FileInputStream(inputFile);
            byte version[] = new byte[VERSION_BYTES];
            Signature sig = new Signature();
            if (VERSION_BYTES != DataHelper.read(in, version))
                throw new IOException("Not enough data for the version bytes");
            sig.readBytes(in);
            return _context.dsa().verifySignature(sig, in, key);
        } catch (IOException ioe) {
            if (_log.shouldLog(Log.WARN))
                _log.warn("Error reading " + inputFile + " to verify", ioe);
            return false;
        } catch (DataFormatException dfe) {
            if (_log.shouldLog(Log.ERROR))
                _log.error("Error reading the signature", dfe);
            return false;
        } finally {
            if (in != null) try { in.close(); } catch (IOException ioe) {}
        }
	}

	/**
	 * Verifies the DSA signature of a signed I2P update.
	 * 
	 * @param inputFile     The signed update file to check.
	 * @param publicKeyFile The public key to use for verification.
	 * 
	 * @return <code>true</code> if the file has a valid signature. 
	 */
	public boolean verify(String inputFile, String publicKeyFile) {
        SigningPublicKey pub = new SigningPublicKey();
        FileInputStream in = null;
        try {
            in = new FileInputStream(inputFile);
            pub.readBytes(in);
        } catch (IOException ioe) {
            if (_log.shouldLog(Log.WARN))
                _log.warn("Unable to load the signature", ioe);
            return false;
        } catch (DataFormatException dfe) {
            if (_log.shouldLog(Log.WARN))
                _log.warn("Unable to load the signature", dfe);
            return false;
        } finally {
            if (in != null) try { in.close(); } catch (IOException ioe) {}
        }
        
        return verify(inputFile, pub);
	}
    
    /**
     * Verify the signature on the signed inputFile, and if it is valid, migrate
     * the raw data out of it and into the outputFile
     *
     * @return true if the signature was valid and the data moved, false otherwise.
     */
    public boolean migrateVerified(String inputFile, String outputFile) {
        boolean ok = verify(inputFile);
        if (!ok) return false;
        FileOutputStream out = null;
        FileInputStream in = null;
        try {
            out = new FileOutputStream(outputFile);
            in = new FileInputStream(inputFile);
            long skipped = 0;
            while (skipped < HEADER_BYTES) {
                skipped += in.skip(HEADER_BYTES - skipped);
            }
            
            byte buf[] = new byte[1024];
            int read = 0;
            while ( (read = in.read(buf)) != -1) 
                out.write(buf, 0, read);
        } catch (IOException ioe) {
            return false;
        } finally {
            if (out != null) try { out.close(); } catch (IOException ioe) {}
            if (in != null) try { in.close(); } catch (IOException ioe) {}
        }
        return true;
    }
}
